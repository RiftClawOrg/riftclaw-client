<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Limbo - RiftClaw</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Rajdhani', sans-serif;
    }
    
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    #ui {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #00d5ff;
      pointer-events: none;
      z-index: 100;
    }
    
    #ui h2 {
      font-size: 24px;
      margin-bottom: 10px;
      text-shadow: 0 0 20px rgba(0, 213, 255, 0.5);
    }
    
    #ui p {
      font-size: 14px;
      opacity: 0.8;
    }
    
    #portal-label {
      position: fixed;
      color: #00d5ff;
      font-size: 16px;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(0, 213, 255, 0.8);
      pointer-events: none;
      display: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="ui">
    <h2>LIMBO</h2>
    <p>Click the portal to enter The Rift</p>
    <p style="font-size: 12px; margin-top: 10px;">WASD to move • Mouse to look • Click portal to travel</p>
  </div>
  
  <div id="portal-label">The Rift →</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Limbo World - Local starting area
    // Simple scene with portal to The Rift
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.FogExp2(0x050510, 0.02);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 5);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);
    
    // Lights
    const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0x00d5ff, 0.5);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    
    // Floor
    const floorGeometry = new THREE.PlaneGeometry(50, 50);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0x0a0a15,
      roughness: 0.8,
      metalness: 0.2
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);
    
    // Grid
    const gridHelper = new THREE.GridHelper(50, 50, 0x00d5ff, 0x1a1a2a);
    scene.add(gridHelper);
    
    // Portal to The Rift
    const portalGroup = new THREE.Group();
    portalGroup.position.set(0, 2, -10);
    
    // Portal frame
    const frameGeometry = new THREE.TorusGeometry(2, 0.2, 16, 100);
    const frameMaterial = new THREE.MeshStandardMaterial({
      color: 0x00d5ff,
      emissive: 0x00d5ff,
      emissiveIntensity: 0.5
    });
    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
    portalGroup.add(frame);
    
    // Portal center (glow)
    const centerGeometry = new THREE.CircleGeometry(1.8, 32);
    const centerMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.3,
      side: THREE.DoubleSide
    });
    const center = new THREE.Mesh(centerGeometry, centerMaterial);
    portalGroup.add(center);
    
    // Portal particles
    const particleCount = 50;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
      const angle = (i / particleCount) * Math.PI * 2;
      const radius = 2 + Math.random() * 0.5;
      positions[i * 3] = Math.cos(angle) * radius;
      positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
      positions[i * 3 + 2] = Math.sin(angle) * radius;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x00d5ff,
      size: 0.05,
      transparent: true,
      opacity: 0.8
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    portalGroup.add(particles);
    
    scene.add(portalGroup);
    
    // Floating crystals
    const crystalGeometry = new THREE.OctahedronGeometry(0.3);
    const crystalMaterial = new THREE.MeshStandardMaterial({
      color: 0xff00ff,
      emissive: 0xff00ff,
      emissiveIntensity: 0.3
    });
    
    const crystals = [];
    for (let i = 0; i < 10; i++) {
      const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
      crystal.position.set(
        (Math.random() - 0.5) * 20,
        1 + Math.random() * 3,
        (Math.random() - 0.5) * 20 - 5
      );
      crystal.userData = {
        speed: 0.5 + Math.random() * 0.5,
        offset: Math.random() * Math.PI * 2
      };
      scene.add(crystal);
      crystals.push(crystal);
    }
    
    // Controls
    const keys = {};
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let yaw = 0;
    let pitch = 0;

    // Keys that Limbo handles (WASD + mouse)
    const limboKeys = ['w', 'a', 's', 'd'];

    document.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      keys[key] = true;

      // Forward non-limbo keys to parent
      if (!limboKeys.includes(key) && window.parent !== window) {
        console.log('[Limbo] Forwarding key to parent:', key);
        window.parent.postMessage({ type: 'keypress', key: e.key }, '*');
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Focus this window for keyboard input
    window.focus();
    console.log('[Limbo] Window focused for keyboard input');
    
    document.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
    
    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;
        
        yaw -= deltaX * 0.005;
        pitch -= deltaY * 0.005;
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }
    });
    
    // Click to travel
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    document.addEventListener('click', (e) => {
      if (isDragging) return;
      
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects([center, frame]);
      
      if (intersects.length > 0) {
        // Travel to The Rift
        if (window.parent !== window) {
          window.parent.postMessage({
            type: 'travel',
            world: 'the-rift',
            url: 'https://rift.riftclaw.com'
          }, '*');
        } else {
          console.log('Travel to The Rift');
        }
      }
    });
    
    // Animation loop
    const clock = new THREE.Clock();
    
    function animate() {
      requestAnimationFrame(animate);
      
      const time = clock.getElapsedTime();
      const delta = clock.getDelta();
      
      // Portal animation
      frame.rotation.z += 0.01;
      center.material.opacity = 0.3 + Math.sin(time * 2) * 0.1;
      
      // Particle animation
      const positions = particles.geometry.attributes.position.array;
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3 + 1] += Math.sin(time * 2 + i) * 0.01;
      }
      particles.geometry.attributes.position.needsUpdate = true;
      particles.rotation.y += 0.005;
      
      // Crystal animation
      crystals.forEach((crystal, i) => {
        crystal.position.y = 2 + Math.sin(time * crystal.userData.speed + crystal.userData.offset) * 0.5;
        crystal.rotation.x += 0.01;
        crystal.rotation.y += 0.02;
      });
      
      // Movement
      const speed = 3 * delta;
      const direction = new THREE.Vector3();
      
      if (keys['w']) direction.z -= 1;
      if (keys['s']) direction.z += 1;
      if (keys['a']) direction.x -= 1;
      if (keys['d']) direction.x += 1;
      
      direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
      direction.normalize();
      
      camera.position.add(direction.multiplyScalar(speed));
      
      // Camera rotation
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
      
      // Portal label
      const portalScreenPos = portalGroup.position.clone().project(camera);
      const portalLabel = document.getElementById('portal-label');
      
      if (portalScreenPos.z < 1) {
        const x = (portalScreenPos.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-(portalScreenPos.y * 0.5) + 0.5) * window.innerHeight;
        
        portalLabel.style.display = 'block';
        portalLabel.style.left = x + 'px';
        portalLabel.style.top = (y - 50) + 'px';
      } else {
        portalLabel.style.display = 'none';
      }
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    console.log('[Limbo] World initialized');
  </script>
</body>
</html>
